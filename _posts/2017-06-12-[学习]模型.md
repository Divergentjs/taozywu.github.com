---
layout:      post
title:       模型
category:    blog
description: 同步阻塞|同步非阻塞|异步阻塞|异步非阻塞
---

## [学习]模型

用户空间与内核空间
为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间

将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间

进程切换
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行

进程的阻塞
* 进程自身的主动操作, 因未到达或未完成自动执行阻塞原语,达到阻塞状态.
* 运行中的进程才可进行阻塞.
* 阻塞后的进程是不占用cpu资源.

文件描述符fd
程序打开或创建文件时,内核给进程返回的一个标示.

缓存 IO
* 大部分IO = 缓存IO
* 数据会先拷贝到内核中的缓冲区,然后在拷贝到应用的地址空间.

缺点:从内核缓冲到应用地址空间来回拷贝  对cpu和内存有开销.


同步阻塞IO

<img src="/images/20170612/Image1.png" width = "300" height = "120" />

应用进程进行调用后,数据会先拷贝到内核缓冲区,然后从缓冲区拷贝到用户空间缓冲区.最后拷贝完成后进行数据处理.


同步非阻塞 IO

应用进程调用后,数据没准备好会立即返回一个error.然后会以轮询方式去进行调用然后查看数据是否已准备好.当数据准备好后进行数据处理.


IO 多路复用

应用进程通过select方式进行监听,任意一个socket的数据OK后则开始进行调用兵处理数据.



信号驱动式IO
信号驱动方式告知数据已准备好进行处理.


异步非阻塞 IO


aio_read方式调用后,无论数据准备好,则都会返回.待数据准备好,内核会发一个通知告知进程并处理数据.



综合考虑:

异步非阻塞IO 是最佳模型.








